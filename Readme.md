# protoxy

A compiler for .proto files into FileDescriptorSets.
Actually python bindings for the [protox](https://github.com/andrewhickman/protox) rust library.


# Installation

```bash
pip install protoxy
```

# Usage

```python
import protoxy

# Compile a proto file (returns a FileDescriptorSets object using the protobuf library)
fds = protoxy.compile(["path/to/file.proto"])

# Compile a proto file (returns a binary FileDescriptorSets object)
fds_bin = protoxy.compile_bin(["path/to/file.proto"])

# Compile a proto file into a dynamic python module
mod = protoxy.compile_module(["path/to/file.proto"])

# The returned module is similar to the one generated by protoc
mod.file_pb2.Message()
```

# Additional options

All those apis have additional options that can be passed as keyword arguments.

```python

fds = protoxy.compile(
    files = ["path/to/file.proto"],
    includes = ["path/to"],
    include_imports = True,
    include_source_info = True,
    use_protoc = False)
```

- files: List of files to compile (can be strings or `os.PathLike` objects)

- includes: List of include paths (can be strings or `os.PathLike` objects), if empty, defaults to the directory path of the first file in `files`

- include_imports: Sets whether the output `FileDescriptorSet` should include imported files.
  only files explicitly included in `files` are included. If this option is set, imported files are included too.

- include_source_info: Include source info in the output (this includes comments found in the source files)

- use_protoc: Use the `protoc` binary to compile the files. If this is set to `True`, the protoc implementation is used using binary found in $PATH. protoc is defacto standard implementation of the protobuf compiler, but using it with python requires to run another binary, which can be a problem in some environments, is slower than the rust implementation and has scalability issue with command line length on windows.